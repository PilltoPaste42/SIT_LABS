%% Входные параметры %%

N = 128;        % Количество бит в передаваемом сигнале
k = 8;          % Шаг сложения
errors = 5;     % Количество случайных ошибок при передаче
tbdepth = 5;    % Глубина поиска соответсвия для алг. Витерби 

% Создание случайного исходного сигнала
source = randi([0 1], 1,N);

%% Создание шфирующего механизма сигнала %%

% Для преобразования сигнала в сверточный код нужно создать так называемую
% шифрующую решетку (trellis), которая из себя представляет механизм
% создания контрольных битов путем сложения определенных двух
% информационных битов.

% Сначала реализуем генераторные полиномы, которые представляют устройство
% сетки

% Для скорости кодирования 1/2 нужно 2 полинома
% Сам полином представляет из себя 1+x^1+x^2+...+x^n

% Коэфициенты могут быть равны 1 или 0, таким образом можно представить
% полином вы виде бинарной последовательности

poly1 = strjoin(string([1 zeros(1, k-2) 1]), ''); % poly1 = 1 + x^n
poly2 = strjoin(string(ones(1, k)), '');          % poly2 = 1+x^1+...+x^n

% Для построение решетки нужно представить полиномы в 8-ричного числа
% Поэтому конвекируем бинарный код в 10-ричное число, затем в 8-ричное, и
% полсе этого записываем 8-ричное 10-ричными числами (само число остается
% 8-ричным)

g1 = str2double(dec2base(bin2dec(poly1),8));
g2 = str2double(dec2base(bin2dec(poly2),8));

% Теперь создадим саму решетку. Для этого нам понадобится:
%   k - колличество битовых блоков для сдвига 
%   [g1 g2] - генераторные полиномы, описываюшие механизм сложения битных
%   блоков

trellis = poly2trellis(k,[g1 g2]);

%% Шифрование сигнала и его передача

% Поле создания сетки, можно приступить к самому шифрованию. Для этого
% воспользуемся функцией convenc, котрая принимает информационный сигнал и
% решетку (структура, опис. правила шифрования) и выдает сверточный код,
% который в нашем случае (R = 1/2) выглядит так: abababab...ab, где:
%   a - инф. бит,
%   b - проверочный бит

code = convenc(source, trellis);

% Теперь симулируем передачу по незащищенному каналу, где есть ошибки

% Сигнал ошибок, где 1 - ошибка в передаваймом бите
errsourse = randerr(1, length(code), errors);

% Полученный после передачи код (там где есть ошибка в errsource, 
% бит заменен на противоположный)
transcode = mod(code + randerr(1, length(code), errors), 2);

%% Декодирование сигнала

% Для декодирования сигана воспользуемся алгоритмом 
% свёрточного декодирования Витерби, который основан на методе 
% максимального правдоподобия. 

% Он реализован в функции vitdec, которая принимает в себя зашиврованый
% сигнал, шифрующую решетку (для сопоставления провер. битов с получ. инф. битами)
% и значение глубины поиска и возвращает расшифрованный сигнал.

decode = vitdec(transcode, trellis, tbdepth, 'trunc', 'hard');

% В результате получаем восстановленный сигнал

%% Анализ полученных результатов

% Сравнение восстановленного сигнала с исходным
figure(1)
plot(xor(decode, source));
grid on;
title('График расхождения востанновленного сигнала с исходным:');
xlabel('bit');
ylabel('error');

% Восстановленный и исходный сигнал
figure(2)
subplot(2,1,1);
plot(decode);
grid on;
title('Восстановленный сигнал:');
xlabel('bits');
ylabel('value');
subplot(2,1,2);
plot(source);
grid on;
title('Исходный сигнал:');
xlabel('bits');
ylabel('value');

% Сравнение закодированного сигнала с переданным
figure(3);
plot(xor(code, transcode));
grid on;
title('График расхождения переданного сигнала с закодированным:');
xlabel('bit');
ylabel('error');

% Сравнение инф. и пров. бит с их переданными версиями
figure(4);
subplot(2,1,1);
plot(xor(code(1:2:end), transcode(1:2:end)));
grid on;
title('Сравнение инф. бит с их переданными версиями:');
xlabel('bit');
ylabel('error');
subplot(2,1,2);
plot(xor(code(2:2:end), transcode(2:2:end)));
grid on;
title('Сравнение пров. бит с их переданными версиями:');
xlabel('bit');
ylabel('error');

% Закодированный сигнал
figure(5)
plot(code);
grid on;
title('Закодированный сигнал:');
xlabel('bits');
ylabel('value');
